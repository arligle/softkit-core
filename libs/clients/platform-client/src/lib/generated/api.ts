/* tslint:disable */
/* eslint-disable */
/**
 * Platform Application is responsible for the common things, like user, tenants, auth, management.
 * It has a common api for tenants and auth. By default designed as a multi-tenant, but you can have only one tenant and manage it like this, in case if in future you would like to expand.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: vitalii.samofal@softkit.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApproveSignUpRequest
 */
export interface ApproveSignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof ApproveSignUpRequest
     */
    'approvalId': string;
    /**
     * 
     * @type {string}
     * @memberof ApproveSignUpRequest
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface AuthControllerSignUp409Response
 */
export interface AuthControllerSignUp409Response {
    /**
     * link to the docs with more details about the error
     * @type {string}
     * @memberof AuthControllerSignUp409Response
     */
    'type': string;
    /**
     * title of the error, short description
     * @type {string}
     * @memberof AuthControllerSignUp409Response
     */
    'title': string;
    /**
     * 
     * @type {number}
     * @memberof AuthControllerSignUp409Response
     */
    'status': number;
    /**
     * detail of the error, comprehensive message for the end user (e.g. \'customer with id 12344321 not found\')
     * @type {string}
     * @memberof AuthControllerSignUp409Response
     */
    'detail': string;
    /**
     * additional data that can be used by the client to handle the error
     * @type {object}
     * @memberof AuthControllerSignUp409Response
     */
    'data'?: object;
    /**
     * error instance, unique identifier for this particular occurrence of the problem
     * @type {string}
     * @memberof AuthControllerSignUp409Response
     */
    'instance': string;
}
/**
 * 
 * @export
 * @interface AuthControllerSignUp409ResponseAllOf
 */
export interface AuthControllerSignUp409ResponseAllOf {
    /**
     * 
     * @type {number}
     * @memberof AuthControllerSignUp409ResponseAllOf
     */
    'status'?: number;
}
/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * User email address
     * @type {string}
     * @memberof CreateUserRequest
     */
    'email': string;
    /**
     * Original password
     * @type {string}
     * @memberof CreateUserRequest
     */
    'password': string;
    /**
     * Repeat password
     * @type {string}
     * @memberof CreateUserRequest
     */
    'repeatedPassword': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'companyName': string;
}
/**
 * 
 * @export
 * @interface CreateUserRole
 */
export interface CreateUserRole {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRole
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRole
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRole
     */
    'roleType'?: CreateUserRoleRoleTypeEnum;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof CreateUserRole
     */
    'permissions'?: Array<Permission>;
}

export const CreateUserRoleRoleTypeEnum = {
    ADMIN: 'ADMIN',
    REGULAR_USER: 'REGULAR_USER'
} as const;

export type CreateUserRoleRoleTypeEnum = typeof CreateUserRoleRoleTypeEnum[keyof typeof CreateUserRoleRoleTypeEnum];

/**
 * 
 * @export
 * @interface CustomUserRoleWithoutPermissionsDto
 */
export interface CustomUserRoleWithoutPermissionsDto {
    /**
     * 
     * @type {string}
     * @memberof CustomUserRoleWithoutPermissionsDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CustomUserRoleWithoutPermissionsDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CustomUserRoleWithoutPermissionsDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CustomUserRoleWithoutPermissionsDto
     */
    'roleType'?: CustomUserRoleWithoutPermissionsDtoRoleTypeEnum;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof CustomUserRoleWithoutPermissionsDto
     */
    'permissions'?: Array<Permission>;
}

export const CustomUserRoleWithoutPermissionsDtoRoleTypeEnum = {
    ADMIN: 'ADMIN',
    REGULAR_USER: 'REGULAR_USER'
} as const;

export type CustomUserRoleWithoutPermissionsDtoRoleTypeEnum = typeof CustomUserRoleWithoutPermissionsDtoRoleTypeEnum[keyof typeof CustomUserRoleWithoutPermissionsDtoRoleTypeEnum];

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * link to the docs with more details about the error
     * @type {string}
     * @memberof ErrorResponse
     */
    'type': string;
    /**
     * title of the error, short description
     * @type {string}
     * @memberof ErrorResponse
     */
    'title': string;
    /**
     * http status code of the error, e.g. 404
     * @type {number}
     * @memberof ErrorResponse
     */
    'status': number;
    /**
     * detail of the error, comprehensive message for the end user (e.g. \'customer with id 12344321 not found\')
     * @type {string}
     * @memberof ErrorResponse
     */
    'detail': string;
    /**
     * additional data that can be used by the client to handle the error
     * @type {object}
     * @memberof ErrorResponse
     */
    'data'?: object;
    /**
     * error instance, unique identifier for this particular occurrence of the problem
     * @type {string}
     * @memberof ErrorResponse
     */
    'instance': string;
}
/**
 * 
 * @export
 * @interface IdpMappingDto
 */
export interface IdpMappingDto {
    /**
     * 
     * @type {string}
     * @memberof IdpMappingDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof IdpMappingDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof IdpMappingDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof IdpMappingDto
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface LinksToPages
 */
export interface LinksToPages {
    /**
     * 
     * @type {string}
     * @memberof LinksToPages
     */
    'first'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinksToPages
     */
    'previous'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinksToPages
     */
    'current'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinksToPages
     */
    'next'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinksToPages
     */
    'last'?: string;
}
/**
 * 
 * @export
 * @interface PaginatedDocumented
 */
export interface PaginatedDocumented {
    /**
     * 
     * @type {Array<object>}
     * @memberof PaginatedDocumented
     */
    'data': Array<object>;
    /**
     * 
     * @type {PaginationMetadata}
     * @memberof PaginatedDocumented
     */
    'meta': PaginationMetadata;
    /**
     * 
     * @type {LinksToPages}
     * @memberof PaginatedDocumented
     */
    'links': LinksToPages;
}
/**
 * 
 * @export
 * @interface PaginatedLinksDocumented
 */
export interface PaginatedLinksDocumented {
    /**
     * 
     * @type {string}
     * @memberof PaginatedLinksDocumented
     */
    'first'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLinksDocumented
     */
    'previous'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLinksDocumented
     */
    'current'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLinksDocumented
     */
    'next'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLinksDocumented
     */
    'last'?: string;
}
/**
 * 
 * @export
 * @interface PaginatedMetaDocumented
 */
export interface PaginatedMetaDocumented {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMetaDocumented
     */
    'itemsPerPage': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedMetaDocumented
     */
    'totalItems': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedMetaDocumented
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedMetaDocumented
     */
    'totalPages': number;
    /**
     * 
     * @type {Array<Array<SortingByColumnsInnerInner>>}
     * @memberof PaginatedMetaDocumented
     */
    'sortBy'?: Array<Array<SortingByColumnsInnerInner>>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaginatedMetaDocumented
     */
    'searchBy'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMetaDocumented
     */
    'search'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaginatedMetaDocumented
     */
    'select'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof PaginatedMetaDocumented
     */
    'filter'?: object;
}
/**
 * 
 * @export
 * @interface PaginationMetadata
 */
export interface PaginationMetadata {
    /**
     * 
     * @type {number}
     * @memberof PaginationMetadata
     */
    'itemsPerPage': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetadata
     */
    'totalItems': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetadata
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof PaginationMetadata
     */
    'totalPages': number;
    /**
     * 
     * @type {Array<Array<SortingByColumnsInnerInner>>}
     * @memberof PaginationMetadata
     */
    'sortBy'?: Array<Array<SortingByColumnsInnerInner>>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaginationMetadata
     */
    'searchBy'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PaginationMetadata
     */
    'search'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaginationMetadata
     */
    'select'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof PaginationMetadata
     */
    'filter'?: object;
}
/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'description': string;
    /**
     * action is the identifier of the permission usually it is the name of the permission in lowercase e.g. admin.user.create, admin.user.read, admin.user.update, admin.user.delete ideally it should be short, up to 16-32 characters because default implementation of auth service keep the permissions in a jwt token and jwt token has a limit of 8kb (8192 characters) in size
     * @type {string}
     * @memberof Permission
     */
    'action': string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'permissionCategoryId': string;
    /**
     * 
     * @type {PermissionCategory}
     * @memberof Permission
     */
    'permissionCategory'?: PermissionCategory | null;
}
/**
 * 
 * @export
 * @interface PermissionCategory
 */
export interface PermissionCategory {
    /**
     * 
     * @type {string}
     * @memberof PermissionCategory
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionCategory
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionCategory
     */
    'description': string;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof PermissionCategory
     */
    'permissions': Array<Permission>;
}
/**
 * 
 * @export
 * @interface RolesControllerFindAll200Response
 */
export interface RolesControllerFindAll200Response {
    /**
     * 
     * @type {Array<CustomUserRoleWithoutPermissionsDto>}
     * @memberof RolesControllerFindAll200Response
     */
    'data': Array<CustomUserRoleWithoutPermissionsDto>;
    /**
     * 
     * @type {RolesControllerFindAll200ResponseAllOfMeta}
     * @memberof RolesControllerFindAll200Response
     */
    'meta': RolesControllerFindAll200ResponseAllOfMeta;
    /**
     * 
     * @type {LinksToPages}
     * @memberof RolesControllerFindAll200Response
     */
    'links': LinksToPages;
}
/**
 * 
 * @export
 * @interface RolesControllerFindAll200ResponseAllOf
 */
export interface RolesControllerFindAll200ResponseAllOf {
    /**
     * 
     * @type {Array<CustomUserRoleWithoutPermissionsDto>}
     * @memberof RolesControllerFindAll200ResponseAllOf
     */
    'data'?: Array<CustomUserRoleWithoutPermissionsDto>;
    /**
     * 
     * @type {RolesControllerFindAll200ResponseAllOfMeta}
     * @memberof RolesControllerFindAll200ResponseAllOf
     */
    'meta'?: RolesControllerFindAll200ResponseAllOfMeta;
}
/**
 * 
 * @export
 * @interface RolesControllerFindAll200ResponseAllOfMeta
 */
export interface RolesControllerFindAll200ResponseAllOfMeta {
    /**
     * 
     * @type {Array<string>}
     * @memberof RolesControllerFindAll200ResponseAllOfMeta
     */
    'select'?: Array<RolesControllerFindAll200ResponseAllOfMetaSelectEnum>;
    /**
     * 
     * @type {RolesControllerFindAll200ResponseAllOfMetaFilter}
     * @memberof RolesControllerFindAll200ResponseAllOfMeta
     */
    'filter'?: RolesControllerFindAll200ResponseAllOfMetaFilter;
}

export const RolesControllerFindAll200ResponseAllOfMetaSelectEnum = {
    ID: 'id',
    NAME: 'name',
    CREATED_AT: 'createdAt',
    UPDATED_AT: 'updatedAt',
    ROLE_TYPE: 'roleType'
} as const;

export type RolesControllerFindAll200ResponseAllOfMetaSelectEnum = typeof RolesControllerFindAll200ResponseAllOfMetaSelectEnum[keyof typeof RolesControllerFindAll200ResponseAllOfMetaSelectEnum];

/**
 * 
 * @export
 * @interface RolesControllerFindAll200ResponseAllOfMetaFilter
 */
export interface RolesControllerFindAll200ResponseAllOfMetaFilter {
    /**
     * 
     * @type {RolesControllerFindAll200ResponseAllOfMetaFilterId}
     * @memberof RolesControllerFindAll200ResponseAllOfMetaFilter
     */
    'id'?: RolesControllerFindAll200ResponseAllOfMetaFilterId;
    /**
     * 
     * @type {RolesControllerFindAll200ResponseAllOfMetaFilterId}
     * @memberof RolesControllerFindAll200ResponseAllOfMetaFilter
     */
    'name'?: RolesControllerFindAll200ResponseAllOfMetaFilterId;
}
/**
 * @type RolesControllerFindAll200ResponseAllOfMetaFilterId
 * @export
 */
export type RolesControllerFindAll200ResponseAllOfMetaFilterId = Array<string> | string;

/**
 * 
 * @export
 * @interface SetupSamlConfiguration
 */
export interface SetupSamlConfiguration {
    /**
     * 
     * @type {string}
     * @memberof SetupSamlConfiguration
     */
    'entryPoint': string;
    /**
     * 
     * @type {string}
     * @memberof SetupSamlConfiguration
     */
    'certificate': string;
    /**
     * 
     * @type {IdpMappingDto}
     * @memberof SetupSamlConfiguration
     */
    'fieldsMapping': IdpMappingDto;
    /**
     * 
     * @type {boolean}
     * @memberof SetupSamlConfiguration
     */
    'enabled': boolean;
}
/**
 * 
 * @export
 * @interface SignInRequest
 */
export interface SignInRequest {
    /**
     * User email address
     * @type {string}
     * @memberof SignInRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof SignInRequest
     */
    'password': string;
}
/**
 * @type SortingByColumnsInnerInner
 * @export
 */
export type SortingByColumnsInnerInner = string;

/**
 * 
 * @export
 * @interface UpdateUserRole
 */
export interface UpdateUserRole {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRole
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRole
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRole
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRole
     */
    'roleType'?: UpdateUserRoleRoleTypeEnum;
}

export const UpdateUserRoleRoleTypeEnum = {
    ADMIN: 'ADMIN',
    REGULAR_USER: 'REGULAR_USER'
} as const;

export type UpdateUserRoleRoleTypeEnum = typeof UpdateUserRoleRoleTypeEnum[keyof typeof UpdateUserRoleRoleTypeEnum];


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ApproveSignUpRequest} ApproveSignUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerApproveSignup: async (ApproveSignUpRequest: ApproveSignUpRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ApproveSignUpRequest' is not null or undefined
            assertParamExists('authControllerApproveSignup', 'ApproveSignUpRequest', ApproveSignUpRequest)
            const localVarPath = `/api/platform/v1/auth/approve-signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ApproveSignUpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSamlAcknowledge: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/platform/v1/auth/sso/saml/ac`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} redirectUrl 
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSamlLogin: async (redirectUrl: string, tenantId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectUrl' is not null or undefined
            assertParamExists('authControllerSamlLogin', 'redirectUrl', redirectUrl)
            // verify required parameter 'tenantId' is not null or undefined
            assertParamExists('authControllerSamlLogin', 'tenantId', tenantId)
            const localVarPath = `/api/platform/v1/auth/sso/saml/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUrl !== undefined) {
                localVarQueryParameter['redirectUrl'] = redirectUrl;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenantId'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignInRequest} SignInRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignIn: async (SignInRequest: SignInRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'SignInRequest' is not null or undefined
            assertParamExists('authControllerSignIn', 'SignInRequest', SignInRequest)
            const localVarPath = `/api/platform/v1/auth/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(SignInRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateUserRequest} CreateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUp: async (CreateUserRequest: CreateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'CreateUserRequest' is not null or undefined
            assertParamExists('authControllerSignUp', 'CreateUserRequest', CreateUserRequest)
            const localVarPath = `/api/platform/v1/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(CreateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        samlControllerSamlMetadata: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/platform/v1/auth/saml/sso/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ApproveSignUpRequest} ApproveSignUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerApproveSignup(ApproveSignUpRequest: ApproveSignUpRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerApproveSignup(ApproveSignUpRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSamlAcknowledge(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSamlAcknowledge(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} redirectUrl 
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSamlLogin(redirectUrl: string, tenantId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSamlLogin(redirectUrl, tenantId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SignInRequest} SignInRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignIn(SignInRequest: SignInRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignIn(SignInRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateUserRequest} CreateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSignUp(CreateUserRequest: CreateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSignUp(CreateUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async samlControllerSamlMetadata(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.samlControllerSamlMetadata(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {ApproveSignUpRequest} ApproveSignUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerApproveSignup(ApproveSignUpRequest: ApproveSignUpRequest, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerApproveSignup(ApproveSignUpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSamlAcknowledge(options?: any): AxiosPromise<void> {
            return localVarFp.authControllerSamlAcknowledge(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} redirectUrl 
         * @param {string} tenantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSamlLogin(redirectUrl: string, tenantId: string, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerSamlLogin(redirectUrl, tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignInRequest} SignInRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignIn(SignInRequest: SignInRequest, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerSignIn(SignInRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateUserRequest} CreateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSignUp(CreateUserRequest: CreateUserRequest, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerSignUp(CreateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        samlControllerSamlMetadata(options?: any): AxiosPromise<void> {
            return localVarFp.samlControllerSamlMetadata(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {ApproveSignUpRequest} ApproveSignUpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerApproveSignup(ApproveSignUpRequest: ApproveSignUpRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerApproveSignup(ApproveSignUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSamlAcknowledge(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSamlAcknowledge(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} redirectUrl 
     * @param {string} tenantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSamlLogin(redirectUrl: string, tenantId: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSamlLogin(redirectUrl, tenantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignInRequest} SignInRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignIn(SignInRequest: SignInRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignIn(SignInRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateUserRequest} CreateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerSignUp(CreateUserRequest: CreateUserRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerSignUp(CreateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public samlControllerSamlMetadata(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).samlControllerSamlMetadata(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateUserRole} CreateUserRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerCreate: async (CreateUserRole: CreateUserRole, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'CreateUserRole' is not null or undefined
            assertParamExists('rolesControllerCreate', 'CreateUserRole', CreateUserRole)
            const localVarPath = `/api/platform/v1/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(CreateUserRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
         * @param {number} [limit] Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 50           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 100           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
         * @param {Array<string>} [filter_id] Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
         * @param {Array<string>} [filter_name] Filter by name query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.name&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.name&#x3D;$not:$like:John Doe&amp;filter.name&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
         * @param {Array<string>} [sortBy] Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; createdAt:DESC,id:DESC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;name&lt;/li&gt; &lt;li&gt;createdAt&lt;/li&gt; &lt;li&gt;updatedAt&lt;/li&gt;&lt;/ul&gt;       
         * @param {string} [search] Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
         * @param {string} [searchBy] List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; name,roleType           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;name&lt;/li&gt; &lt;li&gt;roleType&lt;/li&gt;&lt;/ul&gt;         
         * @param {string} [select] List of fields to select.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; id,name,createdAt,updatedAt,roleType           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields returns. If you want to select only some fields, provide them in query param           &lt;/p&gt;       
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerFindAll: async (page?: number, limit?: number, filter_id?: Array<string>, filter_name?: Array<string>, sortBy?: Array<string>, search?: string, searchBy?: string, select?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/platform/v1/roles/find-all-asdfasdfsdf`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter_id) {
                localVarQueryParameter['filter.id'] = filter_id;
            }

            if (filter_name) {
                localVarQueryParameter['filter.name'] = filter_name;
            }

            if (sortBy) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (searchBy !== undefined) {
                localVarQueryParameter['searchBy'] = searchBy;
            }

            if (select !== undefined) {
                localVarQueryParameter['select'] = select;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Entity id, uuid v4 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rolesControllerFindOne', 'id', id)
            const localVarPath = `/api/platform/v1/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Entity id, uuid v4 format
         * @param {number} version Version number of entity that you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerSoftDelete: async (id: string, version: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rolesControllerSoftDelete', 'id', id)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('rolesControllerSoftDelete', 'version', version)
            const localVarPath = `/api/platform/v1/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerTestProxy: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/platform/v1/roles/test-proxy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Entity id, uuid v4 format
         * @param {UpdateUserRole} UpdateUserRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerUpdateOne: async (id: string, UpdateUserRole: UpdateUserRole, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rolesControllerUpdateOne', 'id', id)
            // verify required parameter 'UpdateUserRole' is not null or undefined
            assertParamExists('rolesControllerUpdateOne', 'UpdateUserRole', UpdateUserRole)
            const localVarPath = `/api/platform/v1/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateUserRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateUserRole} CreateUserRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerCreate(CreateUserRole: CreateUserRole, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomUserRoleWithoutPermissionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerCreate(CreateUserRole, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
         * @param {number} [limit] Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 50           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 100           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
         * @param {Array<string>} [filter_id] Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
         * @param {Array<string>} [filter_name] Filter by name query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.name&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.name&#x3D;$not:$like:John Doe&amp;filter.name&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
         * @param {Array<string>} [sortBy] Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; createdAt:DESC,id:DESC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;name&lt;/li&gt; &lt;li&gt;createdAt&lt;/li&gt; &lt;li&gt;updatedAt&lt;/li&gt;&lt;/ul&gt;       
         * @param {string} [search] Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
         * @param {string} [searchBy] List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; name,roleType           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;name&lt;/li&gt; &lt;li&gt;roleType&lt;/li&gt;&lt;/ul&gt;         
         * @param {string} [select] List of fields to select.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; id,name,createdAt,updatedAt,roleType           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields returns. If you want to select only some fields, provide them in query param           &lt;/p&gt;       
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerFindAll(page?: number, limit?: number, filter_id?: Array<string>, filter_name?: Array<string>, sortBy?: Array<string>, search?: string, searchBy?: string, select?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolesControllerFindAll200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerFindAll(page, limit, filter_id, filter_name, sortBy, search, searchBy, select, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Entity id, uuid v4 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomUserRoleWithoutPermissionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Entity id, uuid v4 format
         * @param {number} version Version number of entity that you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerSoftDelete(id: string, version: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerSoftDelete(id, version, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerTestProxy(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerTestProxy(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Entity id, uuid v4 format
         * @param {UpdateUserRole} UpdateUserRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesControllerUpdateOne(id: string, UpdateUserRole: UpdateUserRole, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomUserRoleWithoutPermissionsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesControllerUpdateOne(id, UpdateUserRole, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateUserRole} CreateUserRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerCreate(CreateUserRole: CreateUserRole, options?: any): AxiosPromise<CustomUserRoleWithoutPermissionsDto> {
            return localVarFp.rolesControllerCreate(CreateUserRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
         * @param {number} [limit] Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 50           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 100           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
         * @param {Array<string>} [filter_id] Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
         * @param {Array<string>} [filter_name] Filter by name query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.name&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.name&#x3D;$not:$like:John Doe&amp;filter.name&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
         * @param {Array<string>} [sortBy] Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; createdAt:DESC,id:DESC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;name&lt;/li&gt; &lt;li&gt;createdAt&lt;/li&gt; &lt;li&gt;updatedAt&lt;/li&gt;&lt;/ul&gt;       
         * @param {string} [search] Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
         * @param {string} [searchBy] List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; name,roleType           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;name&lt;/li&gt; &lt;li&gt;roleType&lt;/li&gt;&lt;/ul&gt;         
         * @param {string} [select] List of fields to select.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; id,name,createdAt,updatedAt,roleType           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields returns. If you want to select only some fields, provide them in query param           &lt;/p&gt;       
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerFindAll(page?: number, limit?: number, filter_id?: Array<string>, filter_name?: Array<string>, sortBy?: Array<string>, search?: string, searchBy?: string, select?: string, options?: any): AxiosPromise<RolesControllerFindAll200Response> {
            return localVarFp.rolesControllerFindAll(page, limit, filter_id, filter_name, sortBy, search, searchBy, select, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Entity id, uuid v4 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerFindOne(id: string, options?: any): AxiosPromise<CustomUserRoleWithoutPermissionsDto> {
            return localVarFp.rolesControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Entity id, uuid v4 format
         * @param {number} version Version number of entity that you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerSoftDelete(id: string, version: number, options?: any): AxiosPromise<boolean> {
            return localVarFp.rolesControllerSoftDelete(id, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerTestProxy(options?: any): AxiosPromise<object> {
            return localVarFp.rolesControllerTestProxy(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Entity id, uuid v4 format
         * @param {UpdateUserRole} UpdateUserRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesControllerUpdateOne(id: string, UpdateUserRole: UpdateUserRole, options?: any): AxiosPromise<CustomUserRoleWithoutPermissionsDto> {
            return localVarFp.rolesControllerUpdateOne(id, UpdateUserRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * 
     * @param {CreateUserRole} CreateUserRole 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesControllerCreate(CreateUserRole: CreateUserRole, options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerCreate(CreateUserRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
     * @param {number} [limit] Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 50           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 100           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
     * @param {Array<string>} [filter_id] Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt;&lt;/ul&gt;
     * @param {Array<string>} [filter_name] Filter by name query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.name&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.name&#x3D;$not:$like:John Doe&amp;filter.name&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$contains&lt;/li&gt;&lt;/ul&gt;
     * @param {Array<string>} [sortBy] Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; createdAt:DESC,id:DESC           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;name&lt;/li&gt; &lt;li&gt;createdAt&lt;/li&gt; &lt;li&gt;updatedAt&lt;/li&gt;&lt;/ul&gt;       
     * @param {string} [search] Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
     * @param {string} [searchBy] List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; name,roleType           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;name&lt;/li&gt; &lt;li&gt;roleType&lt;/li&gt;&lt;/ul&gt;         
     * @param {string} [select] List of fields to select.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; id,name,createdAt,updatedAt,roleType           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields returns. If you want to select only some fields, provide them in query param           &lt;/p&gt;       
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesControllerFindAll(page?: number, limit?: number, filter_id?: Array<string>, filter_name?: Array<string>, sortBy?: Array<string>, search?: string, searchBy?: string, select?: string, options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerFindAll(page, limit, filter_id, filter_name, sortBy, search, searchBy, select, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Entity id, uuid v4 format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Entity id, uuid v4 format
     * @param {number} version Version number of entity that you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesControllerSoftDelete(id: string, version: number, options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerSoftDelete(id, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesControllerTestProxy(options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerTestProxy(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Entity id, uuid v4 format
     * @param {UpdateUserRole} UpdateUserRole 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesControllerUpdateOne(id: string, UpdateUserRole: UpdateUserRole, options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesControllerUpdateOne(id, UpdateUserRole, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TenantsApi - axios parameter creator
 * @export
 */
export const TenantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SetupSamlConfiguration} SetupSamlConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsConfigurationControllerSetupSaml: async (SetupSamlConfiguration: SetupSamlConfiguration, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'SetupSamlConfiguration' is not null or undefined
            assertParamExists('tenantsConfigurationControllerSetupSaml', 'SetupSamlConfiguration', SetupSamlConfiguration)
            const localVarPath = `/api/platform/v1/tenants/configuration/saml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(SetupSamlConfiguration, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantsApi - functional programming interface
 * @export
 */
export const TenantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TenantsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SetupSamlConfiguration} SetupSamlConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenantsConfigurationControllerSetupSaml(SetupSamlConfiguration: SetupSamlConfiguration, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenantsConfigurationControllerSetupSaml(SetupSamlConfiguration, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TenantsApi - factory interface
 * @export
 */
export const TenantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenantsApiFp(configuration)
    return {
        /**
         * 
         * @param {SetupSamlConfiguration} SetupSamlConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenantsConfigurationControllerSetupSaml(SetupSamlConfiguration: SetupSamlConfiguration, options?: any): AxiosPromise<void> {
            return localVarFp.tenantsConfigurationControllerSetupSaml(SetupSamlConfiguration, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TenantsApi - object-oriented interface
 * @export
 * @class TenantsApi
 * @extends {BaseAPI}
 */
export class TenantsApi extends BaseAPI {
    /**
     * 
     * @param {SetupSamlConfiguration} SetupSamlConfiguration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public tenantsConfigurationControllerSetupSaml(SetupSamlConfiguration: SetupSamlConfiguration, options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).tenantsConfigurationControllerSetupSaml(SetupSamlConfiguration, options).then((request) => request(this.axios, this.basePath));
    }
}


