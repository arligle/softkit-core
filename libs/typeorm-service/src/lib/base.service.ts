import { DeepPartial, FindOneOptions, FindOptionsOrder } from 'typeorm';
import { Transactional } from 'typeorm-transactional';
import { BaseEntityHelper, BaseRepository } from '@softkit/typeorm';
import { AbstractBaseService } from './abstract-base.service';
import { toCapitalizedWords } from '@softkit/string-utils';
import { ObjectNotFoundException } from '@softkit/exceptions';
import { PaginateConfig, Paginated, PaginateQuery } from 'nestjs-paginate';
import {
  ClassConstructor,
  instanceToPlain,
  plainToInstance,
} from 'class-transformer';
import { ClassTransformOptions } from 'class-transformer/types/interfaces';

export class BaseEntityService<
  ENTITY extends BaseEntityHelper,
  REPOSITORY extends BaseRepository<ENTITY>,
  EXCLUDE_AUTOGENERATED_FIELDS extends BaseEntityHelper = BaseEntityHelper,
> extends AbstractBaseService<ENTITY, EXCLUDE_AUTOGENERATED_FIELDS> {
  protected entityFriendlyName: string;

  constructor(protected readonly repository: REPOSITORY) {
    super();
    this.entityFriendlyName = toCapitalizedWords(repository.metadata.tableName);
  }

  @Transactional()
  override async findOne(
    findOptions: FindOneOptions<ENTITY>,
    throwExceptionIfNotFound = true,
  ): Promise<ENTITY | undefined> {
    const result = await this.repository.findOne(findOptions);

    if (result === null && throwExceptionIfNotFound) {
      throw new ObjectNotFoundException(this.entityFriendlyName);
    }

    return result ?? undefined;
  }

  @Transactional()
  override async createOrUpdateEntity(
    entity:
      | Omit<ENTITY, keyof Omit<EXCLUDE_AUTOGENERATED_FIELDS, 'version'>>
      | Omit<ENTITY, keyof EXCLUDE_AUTOGENERATED_FIELDS | 'id' | 'version'>,
  ) {
    return this.repository.createOrUpdate(entity as DeepPartial<ENTITY>);
  }

  @Transactional()
  override async createOrUpdateEntities(
    entities:
      | Omit<ENTITY, keyof Omit<EXCLUDE_AUTOGENERATED_FIELDS, 'version'>>[]
      | Omit<ENTITY, keyof EXCLUDE_AUTOGENERATED_FIELDS | 'id' | 'version'>[],
  ) {
    return this.repository.save(entities as DeepPartial<ENTITY>[]);
  }

  @Transactional()
  override async findOneById(
    id: ENTITY['id'],
    throwExceptionIfNotFound = true,
  ) {
    const result = await this.repository.findSingle(id);

    if (throwExceptionIfNotFound && !result) {
      throw new ObjectNotFoundException(this.entityFriendlyName);
    }

    return result ?? undefined;
  }

  @Transactional()
  override async findAllPaginated(
    query: PaginateQuery,
    config: PaginateConfig<ENTITY>,
  ): Promise<Paginated<ENTITY>> {
    return this.repository.findAllPaginated(query, config);
  }

  @Transactional()
  override async findAll(
    page = 1,
    limit = 20,
    order?: FindOptionsOrder<ENTITY>,
  ): Promise<ENTITY[]> {
    return this.repository.find({
      take: limit,
      skip: (page - 1) * limit,
      order: order,
    });
  }

  @Transactional()
  override findAllPaginatedAndTransform<T>(
    query: PaginateQuery,
    config: PaginateConfig<ENTITY>,
    clazz: ClassConstructor<T>,
    // eslint-disable-next-line unicorn/no-object-as-default-parameter
    options: ClassTransformOptions = {
      excludeExtraneousValues: true,
    },
  ): Promise<Paginated<T>> {
    return this.repository.findAllPaginated(query, config).then((paginated) => {
      const data = paginated.data.map((item) => {
        const plain = instanceToPlain(item);
        return plainToInstance(clazz, plain, options);
      });
      return {
        ...paginated,
        data,
      } as never as Paginated<T>;
    });
  }

  @Transactional()
  async archive(id: ENTITY['id'], version: number): Promise<boolean> {
    return this.repository.archive(id, version);
  }

  @Transactional()
  async unarchive(id: ENTITY['id'], version: number): Promise<boolean> {
    return this.repository.unarchive(id, version);
  }

  @Transactional()
  async delete(id: ENTITY['id']): Promise<boolean> {
    const deleteResult = await this.repository.delete(id);
    return deleteResult.affected === 1;
  }
}
