import {
  DeepPartial,
  FindOneOptions,
  FindOptionsOrder,
  FindOptionsWhere,
} from 'typeorm';
import { Transactional } from 'typeorm-transactional';
import { BaseEntityHelper } from '@saas-buildkit/typeorm';
import { AbstractBaseService } from './abstract-base.service';
import { BaseRepository } from '@saas-buildkit/typeorm';
import { toCapitalizedWords } from '@saas-buildkit/string-utils';
import { ObjectNotFoundException } from '@saas-buildkit/exceptions';
import { InfinityPaginationResultType } from '@saas-buildkit/common-types';

export class BaseEntityService<
  ENTITY extends BaseEntityHelper,
  REPOSITORY extends BaseRepository<ENTITY>,
  EXCLUDE_AUTOGENERATED_FIELDS extends BaseEntityHelper = BaseEntityHelper,
> extends AbstractBaseService<ENTITY, EXCLUDE_AUTOGENERATED_FIELDS> {
  protected entityFriendlyName: string;

  constructor(protected readonly repository: REPOSITORY) {
    super();
    this.entityFriendlyName = toCapitalizedWords(repository.metadata.tableName);
  }

  @Transactional()
  protected async findOne(
    findOptions: FindOneOptions<ENTITY>,
    throwExceptionIfNotFound = true,
  ): Promise<ENTITY | undefined> {
    const result = await this.repository.findOne(findOptions);

    if (result === null && throwExceptionIfNotFound) {
      throw new ObjectNotFoundException(this.entityFriendlyName);
    }

    return result === null ? undefined : result;
  }

  @Transactional()
  async createOrUpdateEntity(
    entity:
      | Omit<ENTITY, keyof Omit<EXCLUDE_AUTOGENERATED_FIELDS, 'version'>>
      | Omit<ENTITY, keyof EXCLUDE_AUTOGENERATED_FIELDS | 'id' | 'version'>,
  ) {
    return this.repository.createOrUpdate(entity as DeepPartial<ENTITY>);
  }

  @Transactional()
  async createOrUpdateEntities(
    entities:
      | Omit<ENTITY, keyof Omit<EXCLUDE_AUTOGENERATED_FIELDS, 'version'>>[]
      | Omit<ENTITY, keyof EXCLUDE_AUTOGENERATED_FIELDS | 'id' | 'version'>[],
  ) {
    return this.repository.save(entities as DeepPartial<ENTITY>[]);
  }

  @Transactional()
  async findOneById(id: ENTITY['id'], throwExceptionIfNotFound = true) {
    const result = await this.repository.findSingle(id);

    if (throwExceptionIfNotFound && !result) {
      throw new ObjectNotFoundException(this.entityFriendlyName);
    }

    return result === null ? undefined : result;
  }

  @Transactional()
  async findAll(
    where: FindOptionsWhere<ENTITY> = {},
    page = 0,
    limit = 20,
    sort?: FindOptionsOrder<ENTITY>,
  ): Promise<InfinityPaginationResultType<ENTITY>> {
    const updatedWhereClause = {
      ...where,
    };

    const dataPromise = this.repository.findAllPaginated(
      updatedWhereClause,
      page,
      limit,
      sort,
    );

    const countPromise = this.repository.countBy(updatedWhereClause);

    const [data, count] = await Promise.all([dataPromise, countPromise]);

    return {
      count,
      data,
      hasNextPage: count > (page + 1) * limit,
    };
  }

  @Transactional()
  async archive(id: ENTITY['id'], version: number): Promise<boolean> {
    return this.repository.archive(id, version);
  }

  @Transactional()
  async unarchive(id: ENTITY['id'], version: number): Promise<boolean> {
    return this.repository.unarchive(id, version);
  }

  @Transactional()
  async delete(id: ENTITY['id']): Promise<boolean> {
    const deleteResult = await this.repository.delete(id);
    return deleteResult.affected === 1;
  }
}
