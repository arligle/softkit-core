import { DeepPartial, FindOneOptions } from 'typeorm';
import { Transactional } from 'typeorm-transactional';
import { BaseEntityHelper } from '@saas-buildkit/typeorm';
import { AbstractBaseService } from './abstract-base.service';
import { BaseRepository } from '@saas-buildkit/typeorm';
import { toCapitalizedWords } from '@saas-buildkit/string-utils';
import { ObjectNotFoundException } from '@saas-buildkit/exceptions';
import {
  paginate,
  PaginateConfig,
  Paginated,
  PaginateQuery,
} from 'nestjs-paginate';

export class BaseEntityService<
  ENTITY extends BaseEntityHelper,
  REPOSITORY extends BaseRepository<ENTITY>,
  EXCLUDE_AUTOGENERATED_FIELDS extends BaseEntityHelper = BaseEntityHelper,
> extends AbstractBaseService<ENTITY, EXCLUDE_AUTOGENERATED_FIELDS> {
  protected entityFriendlyName: string;

  constructor(protected readonly repository: REPOSITORY) {
    super();
    this.entityFriendlyName = toCapitalizedWords(repository.metadata.tableName);
  }

  @Transactional()
  override async findOne(
    findOptions: FindOneOptions<ENTITY>,
    throwExceptionIfNotFound = true,
  ): Promise<ENTITY | undefined> {
    const result = await this.repository.findOne(findOptions);

    if (result === null && throwExceptionIfNotFound) {
      throw new ObjectNotFoundException(this.entityFriendlyName);
    }

    return result === null ? undefined : result;
  }

  @Transactional()
  override async createOrUpdateEntity(
    entity:
      | Omit<ENTITY, keyof Omit<EXCLUDE_AUTOGENERATED_FIELDS, 'version'>>
      | Omit<ENTITY, keyof EXCLUDE_AUTOGENERATED_FIELDS | 'id' | 'version'>,
  ) {
    return this.repository.createOrUpdate(entity as DeepPartial<ENTITY>);
  }

  @Transactional()
  override async createOrUpdateEntities(
    entities:
      | Omit<ENTITY, keyof Omit<EXCLUDE_AUTOGENERATED_FIELDS, 'version'>>[]
      | Omit<ENTITY, keyof EXCLUDE_AUTOGENERATED_FIELDS | 'id' | 'version'>[],
  ) {
    return this.repository.save(entities as DeepPartial<ENTITY>[]);
  }

  @Transactional()
  override async findOneById(
    id: ENTITY['id'],
    throwExceptionIfNotFound = true,
  ) {
    const result = await this.repository.findSingle(id);

    if (throwExceptionIfNotFound && !result) {
      throw new ObjectNotFoundException(this.entityFriendlyName);
    }

    return result === null ? undefined : result;
  }

  @Transactional()
  override async findAll(
    query: PaginateQuery,
    config: PaginateConfig<ENTITY>,
  ): Promise<Paginated<ENTITY>> {
    return paginate(query, this.repository, config);
  }

  @Transactional()
  async archive(id: ENTITY['id'], version: number): Promise<boolean> {
    return this.repository.archive(id, version);
  }

  @Transactional()
  async unarchive(id: ENTITY['id'], version: number): Promise<boolean> {
    return this.repository.unarchive(id, version);
  }

  @Transactional()
  async delete(id: ENTITY['id']): Promise<boolean> {
    const deleteResult = await this.repository.delete(id);
    return deleteResult.affected === 1;
  }
}
